import { Injectable } from '@angular/core';
import { FileUploadTypes } from './../helpers/file-types.class';
import { IsNullOrEmpty } from './../helpers/helpers.class';
import * as i0 from "@angular/core";
export class FileUploadService {
    constructor(renderer) {
        this.renderer = renderer;
        this.extensions = ['B', 'KB', 'MB', 'GB'];
        this.sizeRegex = new RegExp(`^(\\d+)(?:\\s{0,1})(${this.extensions.join('|')})?$`, 'i');
    }
    isFileDragDropAvailable() {
        const div = this.renderer.createElement('div');
        return (('draggable' in div) || ('ondragstart' in div && 'ondrop' in div));
    }
    parseSize(value) {
        if (IsNullOrEmpty(value)) {
            return 0;
        }
        if (typeof value === 'number') {
            return value;
        }
        const [, size, extension] = value.match(this.sizeRegex) || [null, '0', 'B'];
        const i = IsNullOrEmpty(extension) ? 0 : this.extensions.indexOf(extension.toUpperCase());
        return parseInt(size, 10) * Math.pow(1024, i < 0 ? 0 : i);
    }
    formatSize(size) {
        return this.calculateSize(size);
    }
    calculateSize(size, extensionIndex = 0) {
        if (isNaN(size)) {
            size = 0;
        }
        if (size < 1024) {
            return `${Math.round(size * 100) / 100} ${this.extensions[extensionIndex]}`;
        }
        return this.calculateSize(size / 1024, extensionIndex + 1);
    }
    getFileType(file) {
        return Object.keys(FileUploadTypes).find((key) => FileUploadTypes[key] === file.type);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.2", ngImport: i0, type: FileUploadService, deps: [{ token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.2", ngImport: i0, type: FileUploadService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.2", ngImport: i0, type: FileUploadService, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i0.Renderer2 }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZS11cGxvYWQuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lwbGFiL25neC1maWxlLXVwbG9hZC9zcmMvbGliL3NlcnZpY2VzL2ZpbGUtdXBsb2FkLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBYSxNQUFNLGVBQWUsQ0FBQztBQUN0RCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFDaEUsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLDRCQUE0QixDQUFDOztBQUszRCxNQUFNLE9BQU8saUJBQWlCO0lBTTFCLFlBQW9CLFFBQW1CO1FBQW5CLGFBQVEsR0FBUixRQUFRLENBQVc7UUFKdEIsZUFBVSxHQUFpQixDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRW5ELGNBQVMsR0FBRyxJQUFJLE1BQU0sQ0FBQyx1QkFBdUIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztJQUdwRyxDQUFDO0lBRU0sdUJBQXVCO1FBQzFCLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQy9DLE9BQU8sQ0FBQyxDQUFDLFdBQVcsSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLGFBQWEsSUFBSSxHQUFHLElBQUksUUFBUSxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDL0UsQ0FBQztJQUVNLFNBQVMsQ0FBQyxLQUFzQjtRQUNuQyxJQUFJLGFBQWEsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO1lBQ3ZCLE9BQU8sQ0FBQyxDQUFDO1FBQ2IsQ0FBQztRQUVELElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxFQUFFLENBQUM7WUFDNUIsT0FBTyxLQUFLLENBQUM7UUFDakIsQ0FBQztRQUVELE1BQU0sQ0FBQyxFQUFFLElBQUksRUFBRSxTQUFTLENBQUMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDNUUsTUFBTSxDQUFDLEdBQUksYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxXQUFXLEVBQVcsQ0FBQyxDQUFDO1FBRXBHLE9BQU8sUUFBUSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzlELENBQUM7SUFFTSxVQUFVLENBQUMsSUFBWTtRQUMxQixPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVPLGFBQWEsQ0FBQyxJQUFZLEVBQUUsaUJBQXlCLENBQUM7UUFDMUQsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztZQUNkLElBQUksR0FBRyxDQUFDLENBQUM7UUFDYixDQUFDO1FBRUQsSUFBSSxJQUFJLEdBQUcsSUFBSSxFQUFFLENBQUM7WUFDZCxPQUFPLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDLEdBQUcsR0FBRyxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLEVBQUUsQ0FBQztRQUNoRixDQUFDO1FBRUQsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksR0FBRyxJQUFJLEVBQUUsY0FBYyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQy9ELENBQUM7SUFFTSxXQUFXLENBQUMsSUFBVTtRQUN6QixPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzFGLENBQUM7OEdBL0NRLGlCQUFpQjtrSEFBakIsaUJBQWlCOzsyRkFBakIsaUJBQWlCO2tCQUQ3QixVQUFVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEZpbGVVcGxvYWRUeXBlcyB9IGZyb20gJy4vLi4vaGVscGVycy9maWxlLXR5cGVzLmNsYXNzJztcclxuaW1wb3J0IHsgSXNOdWxsT3JFbXB0eSB9IGZyb20gJy4vLi4vaGVscGVycy9oZWxwZXJzLmNsYXNzJztcclxuXHJcbmV4cG9ydCB0eXBlIElTaXplID0gJ0InIHwgJ0tCJyB8ICdNQicgfCAnR0InO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgRmlsZVVwbG9hZFNlcnZpY2Uge1xyXG5cclxuICAgIHByaXZhdGUgcmVhZG9ubHkgZXh0ZW5zaW9uczogQXJyYXk8SVNpemU+ID0gWydCJywgJ0tCJywgJ01CJywgJ0dCJ107XHJcblxyXG4gICAgcHJpdmF0ZSByZWFkb25seSBzaXplUmVnZXggPSBuZXcgUmVnRXhwKGBeKFxcXFxkKykoPzpcXFxcc3swLDF9KSgke3RoaXMuZXh0ZW5zaW9ucy5qb2luKCd8Jyl9KT8kYCwgJ2knKTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIpIHtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgaXNGaWxlRHJhZ0Ryb3BBdmFpbGFibGUoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgY29uc3QgZGl2ID0gdGhpcy5yZW5kZXJlci5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICByZXR1cm4gKCgnZHJhZ2dhYmxlJyBpbiBkaXYpIHx8ICgnb25kcmFnc3RhcnQnIGluIGRpdiAmJiAnb25kcm9wJyBpbiBkaXYpKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcGFyc2VTaXplKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIpOiBudW1iZXIge1xyXG4gICAgICAgIGlmIChJc051bGxPckVtcHR5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IFssIHNpemUsIGV4dGVuc2lvbl0gPSB2YWx1ZS5tYXRjaCh0aGlzLnNpemVSZWdleCkgfHwgW251bGwsICcwJywgJ0InXTtcclxuICAgICAgICBjb25zdCBpID0gIElzTnVsbE9yRW1wdHkoZXh0ZW5zaW9uKSA/IDAgOiB0aGlzLmV4dGVuc2lvbnMuaW5kZXhPZihleHRlbnNpb24udG9VcHBlckNhc2UoKSBhcyBJU2l6ZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBwYXJzZUludChzaXplLCAxMCkgKiBNYXRoLnBvdygxMDI0LCBpIDwgMCA/IDAgOiBpKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZm9ybWF0U2l6ZShzaXplOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZVNpemUoc2l6ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVTaXplKHNpemU6IG51bWJlciwgZXh0ZW5zaW9uSW5kZXg6IG51bWJlciA9IDApOiBzdHJpbmcge1xyXG4gICAgICAgIGlmIChpc05hTihzaXplKSkge1xyXG4gICAgICAgICAgICBzaXplID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzaXplIDwgMTAyNCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYCR7TWF0aC5yb3VuZChzaXplICogMTAwKSAvIDEwMH0gJHt0aGlzLmV4dGVuc2lvbnNbZXh0ZW5zaW9uSW5kZXhdfWA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVTaXplKHNpemUgLyAxMDI0LCBleHRlbnNpb25JbmRleCArIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRGaWxlVHlwZShmaWxlOiBGaWxlKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoRmlsZVVwbG9hZFR5cGVzKS5maW5kKChrZXkpID0+IEZpbGVVcGxvYWRUeXBlc1trZXldID09PSBmaWxlLnR5cGUpO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==