import { Directive, forwardRef, Input } from '@angular/core';
import { NG_VALIDATORS } from '@angular/forms';
import { FileUploadValidators } from './../helpers/validators.class';
import { IsNullOrEmpty } from './../helpers/helpers.class';
import * as i0 from "@angular/core";
import * as i1 from "./../services/file-upload.service";
/**
 * A Directive that adds the `filesize` validator to controls marked with the
 * `filesize` attribute. The size of the file is in bytes or any other unit
 *
 * ### Example
 *
 * ```
 * <file-upload name="files" ngModel filesize="830000"></file-upload>
 * <file-upload name="files" ngModel [filesize]="830000"></file-upload>
 * <file-upload name="files" ngModel minSize="0" max="6200"></file-upload>
 * <file-upload name="files" ngModel filesize="123MB"></file-upload>
 * <file-upload name="files" ngModel [filesize]="12 mb"></file-upload>
 * <file-upload name="files" ngModel minSize="0" max="324KB"></file-upload>
 * ```
 *
 */
export class FileSizeValidator {
    constructor(fileUploadService) {
        this.fileUploadService = fileUploadService;
    }
    ngOnChanges(changes) {
        if ('filesize' in changes
            || 'maxsize' in changes
            || 'minsize' in changes) {
            this._createValidator();
            if (this.onChange) {
                this.onChange();
            }
        }
    }
    validate(c) {
        return this.validator(c);
    }
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
    _createValidator() {
        let maxSize = null;
        if (!IsNullOrEmpty(this.maxsize)) {
            maxSize = this.fileUploadService.parseSize(this.maxsize);
        }
        else if (!IsNullOrEmpty(this.filesize)) {
            maxSize = this.fileUploadService.parseSize(this.filesize);
        }
        const minSize = this.fileUploadService.parseSize(this.minsize);
        this.validator = FileUploadValidators.sizeRange({ maxSize, minSize });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.2", ngImport: i0, type: FileSizeValidator, deps: [{ token: i1.FileUploadService }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.2", type: FileSizeValidator, isStandalone: true, selector: "file-upload[filesize][formControlName],\n    file-upload[filesize][formControl],\n    file-upload[filesize][ngModel],\n    file-upload[minsize][formControlName],\n    file-upload[minsize][formControl],\n    file-upload[minsize][ngModel],\n    file-upload[maxsize][formControlName],\n    file-upload[maxsize][formControl],\n    file-upload[maxsize][ngModel]", inputs: { filesize: "filesize", minsize: "minsize", maxsize: "maxsize" }, host: { properties: { "attr.filesize": "filesize ? filesize : null", "attr.minsize": "minsize ? minsize : null", "attr.maxsize": "maxsize ? maxsize : null" } }, providers: [{
                provide: NG_VALIDATORS,
                useExisting: forwardRef(() => FileSizeValidator),
                multi: true
            }], usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.2", ngImport: i0, type: FileSizeValidator, decorators: [{
            type: Directive,
            args: [{
                    selector: `file-upload[filesize][formControlName],
    file-upload[filesize][formControl],
    file-upload[filesize][ngModel],
    file-upload[minsize][formControlName],
    file-upload[minsize][formControl],
    file-upload[minsize][ngModel],
    file-upload[maxsize][formControlName],
    file-upload[maxsize][formControl],
    file-upload[maxsize][ngModel]`,
                    providers: [{
                            provide: NG_VALIDATORS,
                            useExisting: forwardRef(() => FileSizeValidator),
                            multi: true
                        }],
                    host: {
                        '[attr.filesize]': 'filesize ? filesize : null',
                        '[attr.minsize]': 'minsize ? minsize : null',
                        '[attr.maxsize]': 'maxsize ? maxsize : null'
                    },
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.FileUploadService }], propDecorators: { filesize: [{
                type: Input
            }], minsize: [{
                type: Input
            }], maxsize: [{
                type: Input
            }] } });
/**
 * A Directive that adds the `fileslimit` validator to controls marked with the
 * `fileslimit` attribute.
 *
 * ### Example
 *
 * ```
 * <file-upload name="files" ngModel fileslimit="2"></file-upload>
 * <file-upload name="files" ngModel [fileslimit]="2"></file-upload>
 * ```
 *
 */
export class FilesLimitValidator {
    ngOnChanges(changes) {
        if ('fileslimit' in changes) {
            this._createValidator();
            if (this.onChange) {
                this.onChange();
            }
        }
    }
    validate(c) {
        return this.fileslimit != null ? this.validator(c) : null;
    }
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
    _createValidator() {
        this.validator = FileUploadValidators.filesLimit(typeof this.fileslimit === 'string' ? parseInt(this.fileslimit, 10) : this.fileslimit);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.2", ngImport: i0, type: FilesLimitValidator, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.2", type: FilesLimitValidator, isStandalone: true, selector: "file-upload[fileslimit][formControlName], file-upload[fileslimit][formControl], file-upload[fileslimit][ngModel]", inputs: { fileslimit: "fileslimit" }, host: { properties: { "attr.fileslimit": "fileslimit ? fileslimit : null" } }, providers: [{
                provide: NG_VALIDATORS,
                useExisting: forwardRef(() => FilesLimitValidator),
                multi: true
            }], usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.2", ngImport: i0, type: FilesLimitValidator, decorators: [{
            type: Directive,
            args: [{
                    selector: 'file-upload[fileslimit][formControlName], file-upload[fileslimit][formControl], file-upload[fileslimit][ngModel]',
                    providers: [{
                            provide: NG_VALIDATORS,
                            useExisting: forwardRef(() => FilesLimitValidator),
                            multi: true
                        }],
                    host: { '[attr.fileslimit]': 'fileslimit ? fileslimit : null' },
                    standalone: true
                }]
        }], propDecorators: { fileslimit: [{
                type: Input
            }] } });
/**
 * A Directive that adds the `accept` validator to controls marked with the
 * `accept` attribute.
 *
 * ### Example
 *
 * ```
 * <file-upload name="files" ngModel accept="file_extension|audio/*|video/*|image/*|media_type"></file-upload>
 * <file-upload name="files" ngModel [accept]="file_extension|audio/*|video/*|image/*|media_type"></file-upload>
 * ```
 *
 * To specify more than one value, separate the values with a comma (e.g. <file-upload accept="audio/*,video/*,image/*"></file-upload>.
 *
 */
export class FilesAcceptValidator {
    ngOnChanges(changes) {
        if ('accept' in changes) {
            this._createValidator();
            if (this.onChange) {
                this.onChange();
            }
        }
    }
    validate(c) {
        return !!this.validator ? this.validator(c) : null;
    }
    registerOnValidatorChange(fn) {
        this.onChange = fn;
    }
    _createValidator() {
        if (IsNullOrEmpty(this.accept)) {
            return;
        }
        this.validator = FileUploadValidators.accept(this.accept.split(','));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.2", ngImport: i0, type: FilesAcceptValidator, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.2", type: FilesAcceptValidator, isStandalone: true, selector: "file-upload[accept][formControlName], file-upload[accept][formControl], file-upload[accept][ngModel]", inputs: { accept: "accept" }, host: { properties: { "attr.accept": "accept ? accept : null" } }, providers: [{
                provide: NG_VALIDATORS,
                useExisting: forwardRef(() => FilesAcceptValidator),
                multi: true
            }], usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.2", ngImport: i0, type: FilesAcceptValidator, decorators: [{
            type: Directive,
            args: [{
                    selector: 'file-upload[accept][formControlName], file-upload[accept][formControl], file-upload[accept][ngModel]',
                    providers: [{
                            provide: NG_VALIDATORS,
                            useExisting: forwardRef(() => FilesAcceptValidator),
                            multi: true
                        }],
                    host: { '[attr.accept]': 'accept ? accept : null' },
                    standalone: true
                }]
        }], propDecorators: { accept: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdG9ycy5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pcGxhYi9uZ3gtZmlsZS11cGxvYWQvc3JjL2xpYi9kaXJlY3RpdmVzL3ZhbGlkYXRvcnMuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBK0QsTUFBTSxlQUFlLENBQUM7QUFDMUgsT0FBTyxFQUFFLGFBQWEsRUFBOEIsTUFBTSxnQkFBZ0IsQ0FBQztBQUMzRSxPQUFPLEVBQWlDLG9CQUFvQixFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFDcEcsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLDRCQUE0QixDQUFDOzs7QUFJM0Q7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBdUJILE1BQU0sT0FBTyxpQkFBaUI7SUFhMUIsWUFBNkIsaUJBQW9DO1FBQXBDLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBbUI7SUFBRSxDQUFDO0lBSTdELFdBQVcsQ0FBQyxPQUFzQjtRQUNyQyxJQUFJLFVBQVUsSUFBSSxPQUFPO2VBQ2xCLFNBQVMsSUFBSSxPQUFPO2VBQ3BCLFNBQVMsSUFBSSxPQUFPLEVBQUUsQ0FBQztZQUM1QixJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztZQUN4QixJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztnQkFDaEIsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ3BCLENBQUM7UUFDSCxDQUFDO0lBQ0wsQ0FBQztJQUVNLFFBQVEsQ0FBQyxDQUFrQjtRQUM5QixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVNLHlCQUF5QixDQUFDLEVBQWM7UUFDM0MsSUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7SUFDdkIsQ0FBQztJQUVPLGdCQUFnQjtRQUNwQixJQUFJLE9BQU8s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QW9CO2tHQUFwQixvQkFBb0Isb1BBUmxCLENBQUM7Z0JBQ1IsT0FBTyxFQUFFLGFBQWE7Z0JBQ3RCLFdBQVcsRUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsb0JBQW9CLENBQUM7Z0JBQ25ELEtBQUssRUFBRSxJQUFJO2FBQ2QsQ0FBQzs7MkZBSU8sb0JBQW9CO2tCQVZoQyxTQUFTO21CQUFDO29CQUNQLFFBQVEsRUFBRSxzR0FBc0c7b0JBQ2hILFNBQVMsRUFBRSxDQUFDOzRCQUNSLE9BQU8sRUFBRSxhQUFhOzRCQUN0QixXQUFXLEVBQUUsVUFBVSxDQUFDLEdBQUcsRUFBRSxxQkFBcUIsQ0FBQzs0QkFDbkQsS0FBSyxFQUFFLElBQUk7eUJBQ2QsQ0FBQztvQkFDRixJQUFJLEVBQUUsRUFBQyxlQUFlLEVBQUUsd0JBQXdCLEVBQUM7b0JBQ2pELFVBQVUsRUFBRSxJQUFJO2lCQUNuQjs4QkFJVSxNQUFNO3NCQURaLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIGZvcndhcmRSZWYsIElucHV0LCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZXMsIEhvc3QsIFNlbGYsIE9wdGlvbmFsLCBIb3N0QmluZGluZyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBOR19WQUxJREFUT1JTLCBWYWxpZGF0b3IsIEFic3RyYWN0Q29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcclxuaW1wb3J0IHsgVmFsaWRhdGlvbkVycm9ycywgVmFsaWRhdG9yRm4sIEZpbGVVcGxvYWRWYWxpZGF0b3JzIH0gZnJvbSAnLi8uLi9oZWxwZXJzL3ZhbGlkYXRvcnMuY2xhc3MnO1xyXG5pbXBvcnQgeyBJc051bGxPckVtcHR5IH0gZnJvbSAnLi8uLi9oZWxwZXJzL2hlbHBlcnMuY2xhc3MnO1xyXG5pbXBvcnQgeyBGaWxlVXBsb2FkU2VydmljZSB9IGZyb20gJy4vLi4vc2VydmljZXMvZmlsZS11cGxvYWQuc2VydmljZSc7XHJcblxyXG5cclxuLyoqXHJcbiAqIEEgRGlyZWN0aXZlIHRoYXQgYWRkcyB0aGUgYGZpbGVzaXplYCB2YWxpZGF0b3IgdG8gY29udHJvbHMgbWFya2VkIHdpdGggdGhlXHJcbiAqIGBmaWxlc2l6ZWAgYXR0cmlidXRlLiBUaGUgc2l6ZSBvZiB0aGUgZmlsZSBpcyBpbiBieXRlcyBvciBhbnkgb3RoZXIgdW5pdFxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogPGZpbGUtdXBsb2FkIG5hbWU9XCJmaWxlc1wiIG5nTW9kZWwgZmlsZXNpemU9XCI4MzAwMDBcIj48L2ZpbGUtdXBsb2FkPlxyXG4gKiA8ZmlsZS11cGxvYWQgbmFtZT1cImZpbGVzXCIgbmdNb2RlbCBbZmlsZXNpemVdPVwiODMwMDAwXCI+PC9maWxlLXVwbG9hZD5cclxuICogPGZpbGUtdXBsb2FkIG5hbWU9XCJmaWxlc1wiIG5nTW9kZWwgbWluU2l6ZT1cIjBcIiBtYXg9XCI2MjAwXCI+PC9maWxlLXVwbG9hZD5cclxuICogPGZpbGUtdXBsb2FkIG5hbWU9XCJmaWxlc1wiIG5nTW9kZWwgZmlsZXNpemU9XCIxMjNNQlwiPjwvZmlsZS11cGxvYWQ+XHJcbiAqIDxmaWxlLXVwbG9hZCBuYW1lPVwiZmlsZXNcIiBuZ01vZGVsIFtmaWxlc2l6ZV09XCIxMiBtYlwiPjwvZmlsZS11cGxvYWQ+XHJcbiAqIDxmaWxlLXVwbG9hZCBuYW1lPVwiZmlsZXNcIiBuZ01vZGVsIG1pblNpemU9XCIwXCIgbWF4PVwiMzI0S0JcIj48L2ZpbGUtdXBsb2FkPlxyXG4gKiBgYGBcclxuICpcclxuICovXHJcbkBEaXJlY3RpdmUoe1xyXG4gICAgc2VsZWN0b3I6IGBmaWxlLXVwbG9hZFtmaWxlc2l6ZV1bZm9ybUNvbnRyb2xOYW1lXSxcclxuICAgIGZpbGUtdXBsb2FkW2ZpbGVzaXplXVtmb3JtQ29udHJvbF0sXHJcbiAgICBmaWxlLXVwbG9hZFtmaWxlc2l6ZV1bbmdNb2RlbF0sXHJcbiAgICBmaWxlLXVwbG9hZFttaW5zaXplXVtmb3JtQ29udHJvbE5hbWVdLFxyXG4gICAgZmlsZS11cGxvYWRbbWluc2l6ZV1bZm9ybUNvbnRyb2xdLFxyXG4gICAgZmlsZS11cGxvYWRbbWluc2l6ZV1bbmdNb2RlbF0sXHJcbiAgICBmaWxlLXVwbG9hZFttYXhzaXplXVtmb3JtQ29udHJvbE5hbWVdLFxyXG4gICAgZmlsZS11cGxvYWRbbWF4c2l6ZV1bZm9ybUNvbnRyb2xdLFxyXG4gICAgZmlsZS11cGxvYWRbbWF4c2l6ZV1bbmdNb2RlbF1gLFxyXG4gICAgcHJvdmlkZXJzOiBbe1xyXG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXHJcbiAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRmlsZVNpemVWYWxpZGF0b3IpLFxyXG4gICAgICAgIG11bHRpOiB0cnVlXHJcbiAgICB9XSxcclxuICAgIGhvc3Q6IHtcclxuICAgICAgICAnW2F0dHIuZmlsZXNpemVdJzogJ2ZpbGVzaXplID8gZmlsZXNpemUgOiBudWxsJyxcclxuICAgICAgICAnW2F0dHIubWluc2l6ZV0nOiAnbWluc2l6ZSA/IG1pbnNpemUgOiBudWxsJyxcclxuICAgICAgICAnW2F0dHIubWF4c2l6ZV0nOiAnbWF4c2l6ZSA/IG1heHNpemUgOiBudWxsJ1xyXG4gICAgfSxcclxuICAgIHN0YW5kYWxvbmU6IHRydWVcclxufSlcclxuZXhwb3J0IGNsYXNzIEZpbGVTaXplVmFsaWRhdG9yIGltcGxlbWVudHMgVmFsaWRhdG9yLCBPbkNoYW5nZXMge1xyXG5cclxuICAgIEBJbnB1dCgpXHJcbiAgICBwdWJsaWMgZmlsZXNpemU6IHN0cmluZ3xudW1iZXI7XHJcblxyXG4gICAgQElucHV0KClcclxuICAgIHB1YmxpYyBtaW5zaXplOiBzdHJpbmd8bnVtYmVyO1xyXG5cclxuICAgIEBJbnB1dCgpXHJcbiAgICBwdWJsaWMgbWF4c2l6ZTogc3RyaW5nfG51bWJlcjtcclxuXHJcbiAgICBwcml2YXRlIHZhbGlkYXRvcjogVmFsaWRhdG9yRm47XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBmaWxlVXBsb2FkU2VydmljZTogRmlsZVVwbG9hZFNlcnZpY2Upe31cclxuXHJcbiAgICBwcml2YXRlIG9uQ2hhbmdlOiAoKSA9PiB2b2lkO1xyXG5cclxuICAgIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCdmaWxlc2l6ZScgaW4gY2hhbmdlcyBcclxuICAgICAgICAgICAgfHwgJ21heHNpemUnIGluIGNoYW5nZXMgXHJcbiAgICAgICAgICAgIHx8ICdtaW5zaXplJyBpbiBjaGFuZ2VzKSB7XHJcbiAgICAgICAgICB0aGlzLl9jcmVhdGVWYWxpZGF0b3IoKTtcclxuICAgICAgICAgIGlmICh0aGlzLm9uQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdmFsaWRhdGUoYzogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9yc3xudWxsIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0b3IoYyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZm47IFxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2NyZWF0ZVZhbGlkYXRvcigpOiB2b2lkIHtcclxuICAgICAgICBsZXQgbWF4U2l6ZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKCFJc051bGxPckVtcHR5KHRoaXMubWF4c2l6ZSkpIHtcclxuICAgICAgICAgICAgbWF4U2l6ZSA9IHRoaXMuZmlsZVVwbG9hZFNlcnZpY2UucGFyc2VTaXplKHRoaXMubWF4c2l6ZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICghSXNOdWxsT3JFbXB0eSh0aGlzLmZpbGVzaXplKSkge1xyXG4gICAgICAgICAgICBtYXhTaXplID0gdGhpcy5maWxlVXBsb2FkU2VydmljZS5wYXJzZVNpemUodGhpcy5maWxlc2l6ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBtaW5TaXplID0gdGhpcy5maWxlVXBsb2FkU2VydmljZS5wYXJzZVNpemUodGhpcy5taW5zaXplKTtcclxuICAgICAgICB0aGlzLnZhbGlkYXRvciA9IEZpbGVVcGxvYWRWYWxpZGF0b3JzLnNpemVSYW5nZSh7IG1heFNpemUsIG1pblNpemUgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQSBEaXJlY3RpdmUgdGhhdCBhZGRzIHRoZSBgZmlsZXNsaW1pdGAgdmFsaWRhdG9yIHRvIGNvbnRyb2xzIG1hcmtlZCB3aXRoIHRoZVxyXG4gKiBgZmlsZXNsaW1pdGAgYXR0cmlidXRlLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogPGZpbGUtdXBsb2FkIG5hbWU9XCJmaWxlc1wiIG5nTW9kZWwgZmlsZXNsaW1pdD1cIjJcIj48L2ZpbGUtdXBsb2FkPlxyXG4gKiA8ZmlsZS11cGxvYWQgbmFtZT1cImZpbGVzXCIgbmdNb2RlbCBbZmlsZXNsaW1pdF09XCIyXCI+PC9maWxlLXVwbG9hZD5cclxuICogYGBgXHJcbiAqXHJcbiAqL1xyXG5ARGlyZWN0aXZlKHtcclxuICAgIHNlbGVjdG9yOiAnZmlsZS11cGxvYWRbZmlsZXNsaW1pdF1bZm9ybUNvbnRyb2xOYW1lXSwgZmlsZS11cGxvYWRbZmlsZXNsaW1pdF1bZm9ybUNvbnRyb2xdLCBmaWxlLXVwbG9hZFtmaWxlc2xpbWl0XVtuZ01vZGVsXScsXHJcbiAgICBwcm92aWRlcnM6IFt7XHJcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcclxuICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBGaWxlc0xpbWl0VmFsaWRhdG9yKSxcclxuICAgICAgICBtdWx0aTogdHJ1ZVxyXG4gICAgfV0sXHJcbiAgICBob3N0OiB7J1thdHRyLmZpbGVzbGltaXRdJzogJ2ZpbGVzbGltaXQgPyBmaWxlc2xpbWl0IDogbnVsbCd9LFxyXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxyXG59KVxyXG5leHBvcnQgY2xhc3MgRmlsZXNMaW1pdFZhbGlkYXRvciBpbXBsZW1lbnRzIFZhbGlkYXRvciwgT25DaGFuZ2VzIHtcclxuXHJcbiAgICBASW5wdXQoKVxyXG4gICAgcHVibGljIGZpbGVzbGltaXQ6IHN0cmluZ3xudW1iZXI7XHJcblxyXG4gICAgcHJpdmF0ZSB2YWxpZGF0b3I6IFZhbGlkYXRvckZuO1xyXG5cclxuICAgIHByaXZhdGUgb25DaGFuZ2U6ICgpID0+IHZvaWQ7XHJcblxyXG4gICAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcclxuICAgICAgICBpZiAoJ2ZpbGVzbGltaXQnIGluIGNoYW5nZXMpIHtcclxuICAgICAgICAgIHRoaXMuX2NyZWF0ZVZhbGlkYXRvcigpO1xyXG4gICAgICAgICAgaWYgKHRoaXMub25DaGFuZ2UpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdmFsaWRhdGUoYzogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9yc3xudWxsIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maWxlc2xpbWl0ICE9IG51bGwgPyB0aGlzLnZhbGlkYXRvcihjKSA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZm47IFxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2NyZWF0ZVZhbGlkYXRvcigpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnZhbGlkYXRvciA9IEZpbGVVcGxvYWRWYWxpZGF0b3JzLmZpbGVzTGltaXQodHlwZW9mIHRoaXMuZmlsZXNsaW1pdCA9PT0gJ3N0cmluZycgPyBwYXJzZUludCh0aGlzLmZpbGVzbGltaXQsIDEwKSA6IHRoaXMuZmlsZXNsaW1pdCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIERpcmVjdGl2ZSB0aGF0IGFkZHMgdGhlIGBhY2NlcHRgIHZhbGlkYXRvciB0byBjb250cm9scyBtYXJrZWQgd2l0aCB0aGVcclxuICogYGFjY2VwdGAgYXR0cmlidXRlLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKlxyXG4gKiBgYGBcclxuICogPGZpbGUtdXBsb2FkIG5hbWU9XCJmaWxlc1wiIG5nTW9kZWwgYWNjZXB0PVwiZmlsZV9leHRlbnNpb258YXVkaW8vKnx2aWRlby8qfGltYWdlLyp8bWVkaWFfdHlwZVwiPjwvZmlsZS11cGxvYWQ+XHJcbiAqIDxmaWxlLXVwbG9hZCBuYW1lPVwiZmlsZXNcIiBuZ01vZGVsIFthY2NlcHRdPVwiZmlsZV9leHRlbnNpb258YXVkaW8vKnx2aWRlby8qfGltYWdlLyp8bWVkaWFfdHlwZVwiPjwvZmlsZS11cGxvYWQ+XHJcbiAqIGBgYFxyXG4gKiBcclxuICogVG8gc3BlY2lmeSBtb3JlIHRoYW4gb25lIHZhbHVlLCBzZXBhcmF0ZSB0aGUgdmFsdWVzIHdpdGggYSBjb21tYSAoZS5nLiA8ZmlsZS11cGxvYWQgYWNjZXB0PVwiYXVkaW8vKix2aWRlby8qLGltYWdlLypcIj48L2ZpbGUtdXBsb2FkPi5cclxuICpcclxuICovXHJcbkBEaXJlY3RpdmUoe1xyXG4gICAgc2VsZWN0b3I6ICdmaWxlLXVwbG9hZFthY2NlcHRdW2Zvcm1Db250cm9sTmFtZV0sIGZpbGUtdXBsb2FkW2FjY2VwdF1bZm9ybUNvbnRyb2xdLCBmaWxlLXVwbG9hZFthY2NlcHRdW25nTW9kZWxdJyxcclxuICAgIHByb3ZpZGVyczogW3tcclxuICAgICAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxyXG4gICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEZpbGVzQWNjZXB0VmFsaWRhdG9yKSxcclxuICAgICAgICBtdWx0aTogdHJ1ZVxyXG4gICAgfV0sXHJcbiAgICBob3N0OiB7J1thdHRyLmFjY2VwdF0nOiAnYWNjZXB0ID8gYWNjZXB0IDogbnVsbCd9LFxyXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxyXG59KVxyXG5leHBvcnQgY2xhc3MgRmlsZXNBY2NlcHRWYWxpZGF0b3IgaW1wbGVtZW50cyBWYWxpZGF0b3IsIE9uQ2hhbmdlcyB7XHJcblxyXG4gICAgQElucHV0KClcclxuICAgIHB1YmxpYyBhY2NlcHQ6IHN0cmluZztcclxuXHJcbiAgICBwcml2YXRlIHZhbGlkYXRvcjogVmFsaWRhdG9yRm47XHJcblxyXG4gICAgcHJpdmF0ZSBvbkNoYW5nZTogKCkgPT4gdm9pZDtcclxuXHJcbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xyXG4gICAgICAgIGlmICgnYWNjZXB0JyBpbiBjaGFuZ2VzKSB7XHJcbiAgICAgICAgICB0aGlzLl9jcmVhdGVWYWxpZGF0b3IoKTtcclxuICAgICAgICAgIGlmICh0aGlzLm9uQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdmFsaWRhdGUoYzogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9yc3xudWxsIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLnZhbGlkYXRvciA/IHRoaXMudmFsaWRhdG9yKGMpIDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbjogKCkgPT4gdm9pZCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9jcmVhdGVWYWxpZGF0b3IoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKElzTnVsbE9yRW1wdHkodGhpcy5hY2NlcHQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52YWxpZGF0b3IgPSBGaWxlVXBsb2FkVmFsaWRhdG9ycy5hY2NlcHQodGhpcy5hY2NlcHQuc3BsaXQoJywnKSk7XHJcbiAgICB9XHJcbn1cclxuIl19